// Class: ReadBDTMitFisher
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTMitFisher
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/18       [336402]
Creator        : Tita
Date           : Thu Sep 25 18:39:38 2014
Host           : Darwin macbookgrippo87.pi.infn.it 13.1.0 Darwin Kernel Version 13.1.0: Wed Apr 2 23:52:02 PDT 2014; root:xnu-2422.92.1~2/RELEASE_X86_64 x86_64
Dir            : /Users/Tita/Desktop/analysis_HH_bbTauTau/src/HHbbTauTau
Training events: 13719
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "True" [Use multivariate splits using the Fisher criterion]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
pt_mu                         pt_mu                         pt_mu                         pt_mu                                                           'F'    [20.0017700195,366.804962158]
pt_tau                        pt_tau                        pt_tau                        pt_tau                                                          'F'    [20.002986908,287.687713623]
pt_b1                         pt_b1                         pt_b1                         pt_b1                                                           'F'    [20.0108070374,391.747192383]
pt_b2                         pt_b2                         pt_b2                         pt_b2                                                           'F'    [20.0064258575,526.675292969]
DR_bb                         DR_bb                         DR_bb                         DR_bb                                                           'F'    [0.521433293819,5.04560136795]
DR_ll                         DR_ll                         DR_ll                         DR_ll                                                           'F'    [0.506412744522,4.86594104767]
mT2                           mT2                           mT2                           mT2                                                             'F'    [0.026879651472,461.019287109]
Pt_Htt_MET                    Pt_Htt_MET                    Pt_Htt_MET                    Pt_Htt_MET                                                      'F'    [0.702075779438,564.910217285]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTMitFisherNode
   
#ifndef BDTMitFisherNode__def
#define BDTMitFisherNode__def
   
class BDTMitFisherNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTMitFisherNode ( BDTMitFisherNode* left,BDTMitFisherNode* right,
                          int nFisherCoeff,
                          double fisherCoeff0,
                          double fisherCoeff1,
                          double fisherCoeff2,
                          double fisherCoeff3,
                          double fisherCoeff4,
                          double fisherCoeff5,
                          double fisherCoeff6,
                          double fisherCoeff7,
                          double fisherCoeff8,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fNFisherCoeff ( nFisherCoeff ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
     fFisherCoeff.push_back(fisherCoeff0);
     fFisherCoeff.push_back(fisherCoeff1);
     fFisherCoeff.push_back(fisherCoeff2);
     fFisherCoeff.push_back(fisherCoeff3);
     fFisherCoeff.push_back(fisherCoeff4);
     fFisherCoeff.push_back(fisherCoeff5);
     fFisherCoeff.push_back(fisherCoeff6);
     fFisherCoeff.push_back(fisherCoeff7);
     fFisherCoeff.push_back(fisherCoeff8);
   }

   virtual ~BDTMitFisherNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTMitFisherNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTMitFisherNode*   fLeft;     // pointer to the left daughter node
   BDTMitFisherNode*   fRight;    // pointer to the right daughter node
   int                     fNFisherCoeff; // =0 if this node doesn use fisher, else =nvar+1 
   std::vector<double>     fFisherCoeff;  // the fisher coeff (offset at the last element)
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTMitFisherNode::~BDTMitFisherNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
   if (fNFisherCoeff == 0){
     result = (inputValues[fSelector] > fCutValue );
   }else{
     double fisher = fFisherCoeff.at(fFisherCoeff.size()-1);
     for (unsigned int ivar=0; ivar<fFisherCoeff.size()-1; ivar++)
       fisher += fFisherCoeff.at(ivar)*inputValues.at(ivar);
     result = fisher > fCutValue;
   }
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTMitFisherNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTMitFisher : public IClassifierReader {

 public:

   // constructor
   ReadBDTMitFisher( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTMitFisher" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "pt_mu", "pt_tau", "pt_b1", "pt_b2", "DR_bb", "DR_ll", "mT2", "Pt_Htt_MET" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTMitFisher() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTMitFisherNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTMitFisher::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTMitFisherNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTMitFisherNode*)current->GetRight();
         else current=(BDTMitFisherNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDTMitFisher::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(0.361437132072721);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.672169,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.465555,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 81.4022, 1, 0, 0.622502,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.157571,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.3368, 0, 0, 0.575674,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.36347, 1, -1, 0.288484,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53.0306, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.277609);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.595136,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.303245,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.38518, 0, 0, 0.564768,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.230738,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.3368, 0, 0, 0.532601,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.18473, 1, -1, 0.267733,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69.5451, 1, 0, 0.499408,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.388169);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.7053,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.236872,-99) , 
9, 0, 0, 0, 0, 0, 0.320496, 0, 0.0032332, -0.921611, 8, -0.0882732, 0, 0, 0.639187,-99) , 
NN(
0, 
0, 
9, 0, 0, 0, 0, 0, -0.529758, 0, -0.00368558, 1.81927, -1, -0.026972, 0, -1, 0.221881,-99) , 
9, 0, 0, 0, 0, 0, -0.184365, 0, -0.00196141, 0.588829, 8, -0.0463342, 0, 0, 0.535954,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.5444, 0, -1, 0.377138,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 32.7499, 0, 0, 0.469555,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.276441);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.595948,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.348546,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.6005, 0, 0, 0.552642,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.577865,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.2612,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 44.1449, 1, 0, 0.372454,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 90.8177, 1, 0, 0.512338,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.162196,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 109.787, 1, 0, 0.492784,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.213773);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.630019,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.45796,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 77.2092, 1, 0, 0.577689,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.271756,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.49194, 0, 0, 0.542166,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 87.835, 1, -1, 0.405009,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36.5162, 1, 0, 0.466996,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.160898);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.670521,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.390484,-99) , 
9, 0, 0, 0, 0, 0, -0.18832, 0, -0.000506536, 0.444851, 8, -0.0837005, 0, 0, 0.606234,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506014,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.253184,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.5444, 0, 0, 0.471837,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 47.243, 0, 0, 0.505686,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.206476,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 109.787, 1, 0, 0.490423,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.183236);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.590511,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.393813,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.79438, 0, 0, 0.542414,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.508755,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.328023,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 68.2814, 1, 0, 0.44333,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 55.4143, 1, 0, 0.482645,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.249542,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.466054,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.195312);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.641528,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.35658,-99) , 
9, 0, 0, 0, 0, 0, -0.235998, 0, -0.00130525, 0.629881, 8, -0.0374351, 0, 0, 0.544541,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.68904, 0, -1, 0.441569,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 45.4968, 0, 0, 0.472627,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 64.6359, 1, -1, 0.314153,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.10667, 1, 0, 0.452858,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.132958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.536278,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.360541,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.24756, 0, 0, 0.520988,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 105.61, 1, -1, 0.378341,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.501965,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 64.6359, 1, -1, 0.357677,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.10667, 1, 0, 0.484285,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.140323);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.631308,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492067,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.21869, 0, 0, 0.576585,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.538132,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449436,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30.4837, 1, 0, 0.475022,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 59.4711, 1, -1, 0.356773,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89133, 1, 0, 0.450286,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 37.7125, 1, 0, 0.471135,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.126122);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 79.8472, 0, 1, 0.545339,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.525587,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.401533,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.24505, 1, 0, 0.464895,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 55.4143, 1, 0, 0.49695,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.328169,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.485658,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.149946);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.6826, 0, 1, 0.573798,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416834,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 78.473, 1, 0, 0.537928,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.601175,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462065,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 137.822, 0, 0, 0.489034,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 78.7656, 1, -1, 0.360504,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.47746, 1, 0, 0.454896,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 54.4362, 1, 0, 0.475482,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.07931);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.518207,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.393183,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.16774, 0, 0, 0.509503,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.346145,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81.0549, 1, 0, 0.499003,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.336258,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.1292, 0, 0, 0.490466,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.145864);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.531948,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.32939,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 103.522, 1, 0, 0.512736,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.528812,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.103911,-99) , 
9, 0, 0, 0, 0, 0, 0.237267, 0, 0.00272531, -0.719624, 8, -0.086813, 0, 0, 0.445197,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 43.9309, 0, 0, 0.486919,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.34273,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.477518,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.091273);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 3.10667, 1, -1, 0.45449,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0856325);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515243,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.421921,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.68904, 0, 0, 0.497139,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396204,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74.4256, 1, 0, 0.487566,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.502683,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.2988,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.29137, 1, 0, 0.400592,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.10667, 1, 0, 0.477198,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.114416);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621217,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.477139,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 80.0033, 0, 0, 0.529323,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.563579,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.46555,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 70.9906, 0, 0, 0.474253,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.517196,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.207966,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 59.4711, 1, 0, 0.38751,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89133, 1, 0, 0.456417,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 37.7125, 1, 0, 0.468434,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.102289);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.520656,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.428535,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.06877, 1, 0, 0.51115,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.391582,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.08563, 0, 0, 0.502079,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.572665,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.444856,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.134, 1, 0, 0.506665,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.306393,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 59.4711, 1, 0, 0.419418,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89124, 1, 0, 0.484429,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0886031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.608449,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.5444, 0, -1, 0.474096,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 161.904, 0, 0, 0.483544,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.544306,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.319732,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30.4838, 1, 0, 0.406827,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.473556,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.128657);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 34.6224, 1, 1, 0.530315,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.538089,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.178837,-99) , 
9, 0, 0, 0, 0, 0, 0.159891, 0, 0.00201573, -0.508169, 8, -0.0558315, 0, 0, 0.459901,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 41.8392, 0, 0, 0.502574,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.522257,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.339303,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 30.4838, 1, 0, 0.410786,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.490712,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0884827);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.565419,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.472385,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 60.0739, 0, 0, 0.525522,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2.89133, 1, -1, 0.456876,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 37.7125, 1, 0, 0.468185,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0961986);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.527372,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.468378,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 43.9309, 0, 0, 0.505835,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.429374,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74.4256, 1, 0, 0.498321,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.576842,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.468496,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 56.984, 1, 0, 0.522824,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.330243,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 59.4711, 1, 0, 0.44035,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89124, 1, 0, 0.486077,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0727669);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.593061,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.479491,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.08437, 1, 0, 0.543019,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.5444, 0, -1, 0.481026,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 47.243, 0, 0, 0.495068,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510708,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.350692,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.4848, 1, 0, 0.419977,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.485426,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.0744867);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.524147,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.416506,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.16986, 0, 0, 0.516734,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.446027,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 107.303, 1, 0, 0.508662,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 105.61, 1, -1, 0.421907,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.497565,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.156545);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.701111,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.452813,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.81396, 1, 0, 0.585546,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510054,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.368829,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.53691, 0, 0, 0.472472,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 79.8244, 0, 0, 0.505451,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.629248,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.492176,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 33.8001, 1, 0, 0.532531,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.526179,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.18263,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 55.5114, 1, 0, 0.339286,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 68.2714, 1, 0, 0.466498,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.46036, 1, 0, 0.489371,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0643636);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.576562,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506032,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.324997,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.5444, 0, 0, 0.486847,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 161.904, 0, 0, 0.493144,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 105.61, 1, -1, 0.437056,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 87.835, 1, 0, 0.485988,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.119906);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.620797,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.44554,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37.2479, 1, 0, 0.551214,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.396784,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.61587, 0, 0, 0.505621,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.570589,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.482994,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 65.409, 0, 0, 0.494923,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 78.7656, 1, -1, 0.389989,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.47746, 1, 0, 0.46701,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 54.4362, 1, 0, 0.476725,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0255316);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 141.128, 0, 1, 0.505105,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.460001,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.10667, 1, 0, 0.500129,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.430184,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.495753,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.072076);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.557669,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.476121,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41.7868, 1, 0, 0.523782,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.524674,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481203,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 71.7807, 1, 0, 0.496919,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.521433,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.304568,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 59.4711, 1, 0, 0.436264,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89133, 1, 0, 0.485008,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 37.7125, 1, 0, 0.491487,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.119994);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 142.723, 0, 1, 0.528243,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.366557,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 60.434, 0, 0, 0.511858,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.550735,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.42432,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45.8708, 1, 0, 0.516479,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.324924,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 81.3032, 1, 0, 0.471438,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.37478, 1, 0, 0.493669,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.09025);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.672787,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.335187,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.53757, 1, 0, 0.518825,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.5345, 0, -1, 0.477169,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 135.037, 0, 0, 0.482795,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.418213,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.478825,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0526101);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515817,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.422884,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 135.037, 1, 0, 0.508029,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.447003,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.40599, 0, 0, 0.502037,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.44032,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3.20517, 1, 0, 0.498255,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.166643);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.607993,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.368327,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.21395, 1, 0, 0.52002,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.544247,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.404928,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.98834, 0, 0, 0.483589,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 68.2606, 0, 0, 0.497694,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.562003,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.490633,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.134, 1, 0, 0.525272,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.381637,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 59.4711, 1, 0, 0.465147,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89124, 1, 0, 0.490995,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0659542);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.675137,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 66.4327, 0, -1, 0.444595,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 81.6855, 0, 0, 0.520431,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 116.515, 1, -1, 0.481247,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.59862, 1, 0, 0.488553,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.129736);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.580634,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47129,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.21869, 0, 0, 0.536505,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.621732,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.466698,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 67.9021, 0, 0, 0.529019,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.527507,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.357406,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 68.2606, 1, 0, 0.474594,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.02963, 1, 0, 0.49613,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 37.7125, 1, 0, 0.50302,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.136552);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 47.0384, 0, 1, 0.624631,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.563932,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.437274,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 83.8607, 0, 0, 0.477481,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 77.454, 0, 0, 0.528952,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.554974,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.481593,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 40.24, 1, 0, 0.501709,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.571571,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.2431,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 44.1449, 1, 0, 0.381855,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 90.8177, 1, 0, 0.478571,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.02949, 1, 0, 0.497887,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.109839);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 47.0384, 0, 1, 0.592112,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.560221,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.471284,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.88574, 0, 0, 0.489838,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 77.454, 0, 0, 0.525415,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.528086,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.433265,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 99.7637, 1, 0, 0.517173,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.537856,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.269098,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 44.1449, 1, 0, 0.384327,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 90.8177, 1, 0, 0.491953,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.02949, 1, 0, 0.504752,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0736196);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.585618,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.548802,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.477287,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 32.7678, 1, 0, 0.509186,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 91.7392, 0, 0, 0.526457,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.503415,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.449878,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.17903, 1, 0, 0.496041,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510467,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.29124,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 44.1449, 1, 0, 0.386389,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 90.8177, 1, 0, 0.47544,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.02949, 1, 0, 0.494954,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0797958);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 63.1694, 0, 1, 0.548747,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.515215,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.460012,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.67026, 0, 0, 0.484657,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 51.9473, 0, 0, 0.523918,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510754,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.474309,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.03545, 0, 0, 0.4827,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 44.1449, 1, -1, 0.387804,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 90.8177, 1, 0, 0.464991,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.02949, 1, 0, 0.487515,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.056146);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 92.8707, 0, 1, 0.571443,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.511861,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.455331,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.08531, 1, 0, 0.484777,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 66.2735, 0, 0, 0.522813,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 108.519, 1, -1, 0.478944,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.81405, 1, 0, 0.490838,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0442031);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.591453,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.512759,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.467966,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 46.0658, 0, 0, 0.493542,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 81.6855, 0, 0, 0.524542,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506409,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.421384,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 114.571, 1, 0, 0.500293,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.412044,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 116.515, 1, 0, 0.493664,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.59862, 1, 0, 0.499306,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0558109);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.581064,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.510731,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.462158,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.23914, 1, 0, 0.485514,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 77.454, 0, 0, 0.52001,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.574145,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.486021,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.08365, 0, 0, 0.492367,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.415147,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3.2402, 1, 0, 0.485734,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1.59862, 1, 0, 0.491991,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0506828);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.517065,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.445393,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 22.4306, 0, 0, 0.510258,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.428988,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 70.9906, 1, 0, 0.504192,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.463677,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.3368, 0, 0, 0.501037,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.139319);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.572964,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.377484,-99) , 
9, 0, 0, 0, 0, 0, 0.0928656, 0, 0.0012649, -0.304896, 8, -0.0299837, 0, 0, 0.528179,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.501713,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.370464,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 91.5259, 0, 0, 0.443419,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 29.0906, 0, 0, 0.503661,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.549706,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.477337,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37.2478, 1, 0, 0.51725,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.364235,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 81.3032, 1, 0, 0.482485,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2.37478, 1, 0, 0.494132,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.121585);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.525711,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.455815,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 56.8388, 1, 0, 0.515947,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.303023,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.75409, 0, 0, 0.495585,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.69596, 1, 1, 0.552684,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.265668,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.97664, 1, 0, 0.467614,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 108.17, 1, 0, 0.488346,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0904047);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.505801,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.456526,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2.89861, 1, 0, 0.49405,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.329298,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.75409, 0, 0, 0.478588,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.545676,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.46968,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.69596, 1, 0, 0.522469,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.290053,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.97664, 1, 0, 0.454665,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 108.17, 1, 0, 0.472432,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.068083);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.3368, 0, -1, 0.466011,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0340415);
  fForest.push_back( 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1.3368, 0, -1, 0.482986,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0348666);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.506717,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.47625,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 76.7985, 1, 0, 0.500121,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.433255,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 135.037, 1, 0, 0.494527,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.454297,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.3368, 0, 0, 0.49149,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0731274);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.513132,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.434561,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.96154, 0, 0, 0.503869,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.528952,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.379141,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1.99365, 1, 0, 0.471496,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 95.574, 1, 0, 0.492935,-99) , 
NN(
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, 1, 0.50899,-99) , 
NN(
0, 
0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 1, -1, 0.392952,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 81.3032, 0, 0, 0.460976,-99) , 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 21.9789, 0, 0, 0.488629,-99)    );
   return;
};
 
// Clean up
inline void ReadBDTMitFisher::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTMitFisher::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
